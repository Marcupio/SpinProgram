# -*- coding: utf-8 -*-
"""
Created on Fri Mar  8 21:45:12 2019

@author: nac2313
"""

##Determine the probability distribution for AGRs


import numpy as np
import Hamiltonians as H
import time
import multiprocessing as mp
import random
from multiprocessing import Pool
import os
import pathlib as pl
import FilteredStates as fs
from matplotlib import pyplot as plt

#calculates AGR from saved data
N = 12
o = 'open'
p = 'periodic'
modex=o
modey=o
gamamt1=20
gammax1 = 30
c=np.sqrt(2)
uniform1='False'


gammas = np.linspace(0.5,gammax1,gamamt1)

gamm_index = 19


Nstates=30
J1=1
J2=1
phiamt=1000
Nlegs = 3
Na=2
Nb=2
S = 0.5



str1 = pl.PurePath(modex+'x_'+modey+'y')#sorts by boundary conditions first
c2 = str(round(c,3))#rounds the value of c out to 3 decimal places and converts it to string to be used in file destination

path = pl.PurePath(os.getcwd()).parent/'Data'/str1/'Eigenfunctions' ###path and filepaths are objects which allow the program to locate data
filename = 'Eigfuncs__%dx%d_%dphis_J1_%d__J2_%d__%dgammas_%dgammax__%dNstates__%sx_%sy_disorder_onX_onY__c%s__uniform_%s' % (N/Nlegs,Nlegs,phiamt,J1,J2,gamamt1,gammax1,Nstates,modex,modey,c2,uniform1)
filepath = path/filename
 
data = np.load(str(filepath)+'.npz')
Evals = data['Evals']

def getAGRgamma(datum):
    
    def getAGR(sortedEn):
                
        Adgphi = []#find all adgr(r) for a given phi, but each phi corresponds to a unique Hamiltonian i.e. H(phi)
        for n in range(1,len(sortedEn)-1):
                
           Enb = sortedEn[n+1]
           Ena = sortedEn[n-1]
           En = sortedEn[n]
           AGn = Enb - En
           AGa = En - Ena
                    
           A = min(AGn,AGa)/max(AGn,AGa)
           Adgphi.append(A)
                    
        return(Adgphi)

    sortedEns = [sorted(vals) for vals in datum]#sorts the Eigenvalues for each phi iteration by increasing value.
    
    AGRphis = np.array([getAGR(En) for En in sortedEns]).flatten()#gets all AGR values for a single gamma
    return(AGRphis)

AGR = np.array(getAGRgamma(Evals[gamm_index])).flatten() 

counts, binedges = np.histogram(AGR,bins=50)


#need to generate probability 
def normcounts(countarray):
    
    total = np.sum(countarray)
    ncounts = countarray/total#note that countarray is a numpy array generated by np.histogram(data), otherwise one would need [c/total for c in countarray] to get the same result
    return(ncounts)

Pr = normcounts(counts)
AGR_Range = np.linspace(binedges.min(),binedges.max(),len(counts))



degen=[]
for x in AGR:
    
    if x < 1e-8:
        degen.append(x)
    else:
        degen=degen
      
print(len(degen),str(len(degen)/len(AGR)*100) + '%',gammas[gamm_index])
print(gammas[gamm_index])
plt.step(AGR_Range,Pr,where='post')
plt.xlabel('r')
plt.ylabel('P(r)')
plt.show()


